///////////////////////////////////////////////////////////////////////////////////////////////////
// sprite_importer.js - CSE 380 Final Project												 	 //
//																								 //
// This program imports a spritesheet created using the graphic design program Animated Poseur.  //
// Animated Poseur generates a .json file that contains neatly formatted data for each frame     //
// of animation created for the sprite. This includes the animation state, frame duration, and   //
// the x&y offsets in the spritesheet. Using the data from this .json file, this program will    //
// import the sprite, and all of its animation states, into a Phaser game. The program can be    //
// used by simply calling importAPSprite(game, sheetPath, animPath) in the preload() method of   //
// the Phaser game code. The generated animation frames of the spritesheet will be written to    //
// the villainAnimations object, with the key being the name of the animation. I.E. the frames   //
// of the animation 'walking_left' can be accessed by: villainAnimations['walking_left']. 		 //
//																							     //
// (c) 2017 <Team Name>																			 //
//																								 //
// Authors: Daniel Gomm, Noam Dorogoyer, Tristen Terracciano									 //
//																								 //
///////////////////////////////////////////////////////////////////////////////////////////////////

//Ensure global game object is defined
var ProtectorGame = ProtectorGame || {};

//define the sprite importer object inside the global game object
ProtectorGame.sprite_importer = {};

//the global object containing all the villain animation frame mapping arrays
ProtectorGame.sprite_importer.villainAnimations = {};

//the height and width (in pixels) of the spritesheet
var imgWidth;
var imgHeight;

var jsonData;
/*
	This function imports a sprite created using the program Animated Poseur. The sprite is imported 
	by reading the data in the given json file to create the correct animations found in the spritesheet. 

	PARAMS	:	game - The reference to the Phaser.Game object
		        sheetPath - The file path to the spritesheet to eb imported
		        animPath - The file path to the .json data file
	
	OUTPUT  :   villainAnimations - This object holds an array for each animation imported by this function. 
									When the function has completed, the frames for each animation will be
									stored in an array with he object key being the name of the array. Since
									this function is being called during the preload() Phaser function, it 
									cannot call villain.animations.add() because the villain has not yet been
									added to the game. To accomodate for this, the frame data and animation 
									names are stored in the object and can be accessed by the game script, 
									AnimatedPoseurViewer. The game script can then construct the animations
									by simply using the data generated by this function.
*/
ProtectorGame.sprite_importer.importAPSprite = function(game, sheetPath, animPath) {
	//temporarily load spritesheet into DOM so that the importer can get its dimensions
	document.getElementById("spritesheet").src = sheetPath;

	//jquery -- this will run when the DOM is finished loading
	$(document).ready(function() {
		console.log("document ready");
		$.getJSON(animPath, function(data) {
			//log to console that the success callback function was called, and display the JSON data
			console.log("<APImporter> Successfully loaded JSON data file : " + data.name);
			console.log(data);

			//set the global variable for access to json data
			jsonData = data;

			//add the villain object to the game
			console.log("<APImporter> Loading Spritesheet : " + sheetPath);
			//load the spritesheet into the game object so it can be parsed
			game.load.spritesheet('villain', sheetPath, 64, 96);

			console.log("<APImporter> parsing AP spritesheet dimensions. . . ");

			//get the dimensions of the spritesheet 
			imgWidth = document.getElementById("spritesheet").width;
			imgHeight = document.getElementById("spritesheet").height;
			//unload the spritesheet from the DOM so that the game can be loaded
			console.log("<APImporter> Unloading spritesheet from DOM. . .")
			document.getElementById("spritesheet").src = "";
			//log the spritesheet dimensions
			console.log("<APImporter> Spritesheet dimensions: w : " + imgWidth + " h : " + imgHeight);

			//temporary array that holds the frame numbers (in the spritesheet) that correspond to each animation
			var tempFrames = []; 

			//holds the name of the current state being created. 
			var currentState = data.frameData[0].state;
			
			for(var i=0; i < data.frameData.length; i++) {
				//hold the animation state of this JSON entry
				var tempState = data.frameData[i].state;

				//divide pixel offsets by sprite pixel width/height to get frame offsets for X and Y
				var frameOffsetX = data.frameData[i].offsetX/data.width;
				var frameOffsetY = data.frameData[i].offsetY/data.height;

				//define maximum frame offset (x direction)
				var MAX_X_FRAME_OFFSET = imgWidth/data.width;

				//finds the current frame of the spritesheet using the JSON file's given offsets
				var currentSpriteSheetFrame = frameOffsetX + (MAX_X_FRAME_OFFSET * frameOffsetY);		

				//if the the state of the animation has changed, create the animation and move on to next
				if(currentState != tempState || i == data.frameData.length - 1) {
					//save animation frames
					ProtectorGame.sprite_importer.villainAnimations[currentState] = tempFrames;
					console.log("<APImporter> Animation Created : " + currentState + " [ " + tempFrames + " ] ");
					currentState = tempState;
					tempFrames = [];
				}
				else {
					tempFrames.push(currentSpriteSheetFrame);
				}
			}	
		});
	});
}